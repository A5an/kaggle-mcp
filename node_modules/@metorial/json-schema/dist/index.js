// src/openApi.ts
var jsonSchemaToOpenApi = (jsonSchema, options = {}) => {
  let {
    openApiVersion = "3.0.0",
    preserveJsonSchemaKeywords = false,
    nullHandling = "nullable"
  } = options;
  if (typeof jsonSchema === "boolean") {
    return jsonSchema ? {} : { not: {} };
  }
  if (jsonSchema.$ref) {
    return {
      $ref: transformRef(jsonSchema.$ref)
    };
  }
  let result = {};
  if ("allOf" in jsonSchema && jsonSchema.allOf) {
    result.allOf = jsonSchema.allOf.map((schema) => jsonSchemaToOpenApi(schema, options));
  }
  if ("anyOf" in jsonSchema && jsonSchema.anyOf) {
    result.anyOf = jsonSchema.anyOf.map((schema) => jsonSchemaToOpenApi(schema, options));
  }
  if ("oneOf" in jsonSchema && jsonSchema.oneOf) {
    result.oneOf = jsonSchema.oneOf.map((schema) => jsonSchemaToOpenApi(schema, options));
  }
  if ("not" in jsonSchema && jsonSchema.not) {
    result.not = jsonSchemaToOpenApi(jsonSchema.not, options);
  }
  if (jsonSchema.type) {
    if (Array.isArray(jsonSchema.type)) {
      let types = jsonSchema.type.filter((t) => t !== "null");
      let hasNull = jsonSchema.type.includes("null");
      if (types.length === 1) {
        result.type = types[0];
        if (hasNull && nullHandling === "nullable") {
          result.nullable = true;
        }
      } else if (types.length > 1) {
        result.anyOf = types.map((type) => ({ type }));
        if (hasNull && nullHandling === "nullable") {
          result.nullable = true;
        }
      }
    } else if (jsonSchema.type === "null") {
      if (nullHandling === "nullable") {
        result.nullable = true;
      } else if (nullHandling === "preserve") {
        result.type = "null";
      }
    } else {
      result.type = jsonSchema.type;
    }
  }
  let commonProps = [
    "title",
    "description",
    "default",
    "enum",
    "const",
    "readOnly",
    "writeOnly",
    "deprecated"
  ];
  for (let prop of commonProps) {
    if (jsonSchema[prop] !== void 0)
      result[prop] = jsonSchema[prop];
  }
  if (jsonSchema.examples && jsonSchema.examples.length > 0) {
    if (openApiVersion === "3.1.0") {
      result.examples = jsonSchema.examples;
    } else {
      result.example = jsonSchema.examples[0];
    }
  }
  if (jsonSchema.type === "string") {
    let stringProps = ["minLength", "maxLength", "pattern", "format"];
    stringProps.forEach((prop) => {
      if (jsonSchema[prop] !== void 0) {
        result[prop] = jsonSchema[prop];
      }
    });
  }
  if (jsonSchema.type === "number" || jsonSchema.type === "integer") {
    let numericProps = ["minimum", "maximum", "multipleOf"];
    numericProps.forEach((prop) => {
      if (jsonSchema[prop] !== void 0) {
        result[prop] = jsonSchema[prop];
      }
    });
    if (typeof jsonSchema.exclusiveMinimum === "number") {
      result.minimum = jsonSchema.exclusiveMinimum;
      result.exclusiveMinimum = true;
    } else if (typeof jsonSchema.exclusiveMinimum === "boolean") {
      result.exclusiveMinimum = jsonSchema.exclusiveMinimum;
    }
    if (typeof jsonSchema.exclusiveMaximum === "number") {
      result.maximum = jsonSchema.exclusiveMaximum;
      result.exclusiveMaximum = true;
    } else if (typeof jsonSchema.exclusiveMaximum === "boolean") {
      result.exclusiveMaximum = jsonSchema.exclusiveMaximum;
    }
  }
  if (jsonSchema.type === "array") {
    let arrayProps = ["minItems", "maxItems", "uniqueItems"];
    arrayProps.forEach((prop) => {
      if (jsonSchema[prop] !== void 0) {
        result[prop] = jsonSchema[prop];
      }
    });
    if (jsonSchema.items) {
      if (Array.isArray(jsonSchema.items)) {
        result.items = {
          anyOf: jsonSchema.items.map((item) => jsonSchemaToOpenApi(item, options))
        };
      } else {
        result.items = jsonSchemaToOpenApi(jsonSchema.items, options);
      }
    }
  }
  if (jsonSchema.type === "object") {
    let objectProps = ["required", "minProperties", "maxProperties"];
    objectProps.forEach((prop) => {
      if (jsonSchema[prop] !== void 0) {
        result[prop] = jsonSchema[prop];
      }
    });
    if (jsonSchema.properties) {
      result.properties = {};
      Object.entries(jsonSchema.properties).forEach(([key, schema]) => {
        result.properties[key] = jsonSchemaToOpenApi(schema, options);
      });
    }
    if (jsonSchema.additionalProperties !== void 0) {
      if (typeof jsonSchema.additionalProperties === "boolean") {
        result.additionalProperties = jsonSchema.additionalProperties;
      } else {
        result.additionalProperties = jsonSchemaToOpenApi(
          jsonSchema.additionalProperties,
          options
        );
      }
    }
  }
  if (!preserveJsonSchemaKeywords) {
    let jsonSchemaOnlyKeywords = [
      "$schema",
      "$id",
      "$defs",
      "definitions",
      "patternProperties",
      "dependencies",
      "propertyNames",
      "contains",
      "additionalItems",
      "if",
      "then",
      "else"
    ];
    jsonSchemaOnlyKeywords.forEach((keyword) => {
      delete result[keyword];
    });
  }
  return result;
};
function transformRef(ref) {
  if (ref.startsWith("#/$defs/")) {
    return ref.replace("#/$defs/", "#/components/schemas/");
  }
  if (ref.startsWith("#/definitions/")) {
    return ref.replace("#/definitions/", "#/components/schemas/");
  }
  return ref;
}

export { jsonSchemaToOpenApi };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map