{"version":3,"sources":["../src/openApi.ts"],"names":[],"mappings":"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","sourcesContent":["import { JsonSchema } from './types';\n\nexport interface OpenApiSchema {\n  type?: 'string' | 'number' | 'integer' | 'boolean' | 'array' | 'object';\n  format?: string;\n  title?: string;\n  description?: string;\n  default?: any;\n  example?: any;\n  examples?: any[];\n  enum?: any[];\n  const?: any;\n\n  // String-specific\n  minLength?: number;\n  maxLength?: number;\n  pattern?: string;\n\n  // Number-specific\n  minimum?: number;\n  maximum?: number;\n  exclusiveMinimum?: boolean;\n  exclusiveMaximum?: boolean;\n  multipleOf?: number;\n\n  // Array-specific\n  items?: OpenApiSchema;\n  minItems?: number;\n  maxItems?: number;\n  uniqueItems?: boolean;\n\n  // Object-specific\n  properties?: Record<string, OpenApiSchema>;\n  additionalProperties?: OpenApiSchema | boolean;\n  required?: string[];\n  minProperties?: number;\n  maxProperties?: number;\n\n  // Composition\n  allOf?: OpenApiSchema[];\n  oneOf?: OpenApiSchema[];\n  anyOf?: OpenApiSchema[];\n  not?: OpenApiSchema;\n\n  // OpenAPI specific\n  nullable?: boolean;\n  discriminator?: {\n    propertyName: string;\n    mapping?: Record<string, string>;\n  };\n  readOnly?: boolean;\n  writeOnly?: boolean;\n  xml?: {\n    name?: string;\n    namespace?: string;\n    prefix?: string;\n    attribute?: boolean;\n    wrapped?: boolean;\n  };\n  externalDocs?: {\n    description?: string;\n    url: string;\n  };\n  deprecated?: boolean;\n\n  // Reference\n  $ref?: string;\n}\n\n/**\n * Converts a JSON Schema to an OpenAPI Schema\n * @param jsonSchema - The JSON Schema to convert\n * @param options - Conversion options\n * @returns OpenAPI Schema\n */\nexport let jsonSchemaToOpenApi = (\n  jsonSchema: JsonSchema,\n  options: {\n    /**\n     * OpenAPI version to target (affects some conversion behaviors)\n     * @default \"3.0.0\"\n     */\n    openApiVersion?: '3.0.0' | '3.1.0';\n\n    /**\n     * Whether to preserve JSON Schema specific keywords that aren't part of OpenAPI\n     * @default false\n     */\n    preserveJsonSchemaKeywords?: boolean;\n\n    /**\n     * How to handle null types (JSON Schema allows type: null, OpenAPI uses nullable)\n     * @default \"nullable\"\n     */\n    nullHandling?: 'nullable' | 'remove' | 'preserve';\n  } = {}\n): OpenApiSchema => {\n  let {\n    openApiVersion = '3.0.0',\n    preserveJsonSchemaKeywords = false,\n    nullHandling = 'nullable'\n  } = options;\n\n  // Handle boolean schemas\n  if (typeof jsonSchema === 'boolean') {\n    return jsonSchema ? {} : { not: {} };\n  }\n\n  // Handle $ref\n  if (jsonSchema.$ref) {\n    return {\n      $ref: transformRef(jsonSchema.$ref)\n    };\n  }\n\n  let result: OpenApiSchema = {};\n\n  // Handle composition keywords\n  if ('allOf' in jsonSchema && jsonSchema.allOf) {\n    result.allOf = jsonSchema.allOf.map(schema => jsonSchemaToOpenApi(schema, options));\n  }\n\n  if ('anyOf' in jsonSchema && jsonSchema.anyOf) {\n    result.anyOf = jsonSchema.anyOf.map(schema => jsonSchemaToOpenApi(schema, options));\n  }\n\n  if ('oneOf' in jsonSchema && jsonSchema.oneOf) {\n    result.oneOf = jsonSchema.oneOf.map(schema => jsonSchemaToOpenApi(schema, options));\n  }\n\n  if ('not' in jsonSchema && jsonSchema.not) {\n    result.not = jsonSchemaToOpenApi(jsonSchema.not, options);\n  }\n\n  // Handle type\n  if (jsonSchema.type) {\n    if (Array.isArray(jsonSchema.type)) {\n      // JSON Schema allows array of types, OpenAPI doesn't\n      let types = jsonSchema.type.filter(t => t !== 'null');\n      let hasNull = jsonSchema.type.includes('null');\n\n      if (types.length === 1) {\n        result.type = types[0] as any;\n        if (hasNull && nullHandling === 'nullable') {\n          result.nullable = true;\n        }\n      } else if (types.length > 1) {\n        // Convert to anyOf\n        result.anyOf = types.map(type => ({ type: type as any }));\n        if (hasNull && nullHandling === 'nullable') {\n          result.nullable = true;\n        }\n      }\n    } else if (jsonSchema.type === 'null') {\n      if (nullHandling === 'nullable') {\n        result.nullable = true;\n      } else if (nullHandling === 'preserve') {\n        result.type = 'null' as any;\n      }\n      // If nullHandling === 'remove', we don't set type\n    } else {\n      result.type = jsonSchema.type;\n    }\n  }\n\n  // Copy common properties\n  let commonProps = [\n    'title',\n    'description',\n    'default',\n    'enum',\n    'const',\n    'readOnly',\n    'writeOnly',\n    'deprecated'\n  ] as const;\n\n  for (let prop of commonProps) {\n    // @ts-ignore\n    if (jsonSchema[prop] !== undefined) (result as any)[prop] = jsonSchema[prop];\n  }\n\n  // Handle examples vs example\n  if (jsonSchema.examples && jsonSchema.examples.length > 0) {\n    if (openApiVersion === '3.1.0') {\n      result.examples = jsonSchema.examples;\n    } else {\n      // OpenAPI 3.0 uses singular 'example'\n      result.example = jsonSchema.examples[0];\n    }\n  }\n\n  // Type-specific properties\n  if (jsonSchema.type === 'string') {\n    let stringProps = ['minLength', 'maxLength', 'pattern', 'format'] as const;\n    stringProps.forEach(prop => {\n      if (jsonSchema[prop] !== undefined) {\n        (result as any)[prop] = jsonSchema[prop];\n      }\n    });\n  }\n\n  if (jsonSchema.type === 'number' || jsonSchema.type === 'integer') {\n    let numericProps = ['minimum', 'maximum', 'multipleOf'] as const;\n    numericProps.forEach(prop => {\n      if (jsonSchema[prop] !== undefined) {\n        (result as any)[prop] = jsonSchema[prop];\n      }\n    });\n\n    // Handle exclusive minimum/maximum\n    if (typeof jsonSchema.exclusiveMinimum === 'number') {\n      result.minimum = jsonSchema.exclusiveMinimum;\n      result.exclusiveMinimum = true;\n    } else if (typeof jsonSchema.exclusiveMinimum === 'boolean') {\n      result.exclusiveMinimum = jsonSchema.exclusiveMinimum;\n    }\n\n    if (typeof jsonSchema.exclusiveMaximum === 'number') {\n      result.maximum = jsonSchema.exclusiveMaximum;\n      result.exclusiveMaximum = true;\n    } else if (typeof jsonSchema.exclusiveMaximum === 'boolean') {\n      result.exclusiveMaximum = jsonSchema.exclusiveMaximum;\n    }\n  }\n\n  if (jsonSchema.type === 'array') {\n    let arrayProps = ['minItems', 'maxItems', 'uniqueItems'] as const;\n    arrayProps.forEach(prop => {\n      if (jsonSchema[prop] !== undefined) {\n        (result as any)[prop] = jsonSchema[prop];\n      }\n    });\n\n    if (jsonSchema.items) {\n      if (Array.isArray(jsonSchema.items)) {\n        // JSON Schema allows array of schemas for tuple validation\n        // OpenAPI doesn't support this directly, so we use anyOf\n        result.items = {\n          anyOf: jsonSchema.items.map(item => jsonSchemaToOpenApi(item, options))\n        };\n      } else {\n        result.items = jsonSchemaToOpenApi(jsonSchema.items, options);\n      }\n    }\n  }\n\n  if (jsonSchema.type === 'object') {\n    let objectProps = ['required', 'minProperties', 'maxProperties'] as const;\n    objectProps.forEach(prop => {\n      if (jsonSchema[prop] !== undefined) {\n        (result as any)[prop] = jsonSchema[prop];\n      }\n    });\n\n    if (jsonSchema.properties) {\n      result.properties = {};\n      Object.entries(jsonSchema.properties).forEach(([key, schema]) => {\n        result.properties![key] = jsonSchemaToOpenApi(schema, options);\n      });\n    }\n\n    if (jsonSchema.additionalProperties !== undefined) {\n      if (typeof jsonSchema.additionalProperties === 'boolean') {\n        result.additionalProperties = jsonSchema.additionalProperties;\n      } else {\n        result.additionalProperties = jsonSchemaToOpenApi(\n          jsonSchema.additionalProperties,\n          options\n        );\n      }\n    }\n  }\n\n  // Handle JSON Schema keywords that aren't in OpenAPI\n  if (!preserveJsonSchemaKeywords) {\n    // Remove JSON Schema specific keywords\n    let jsonSchemaOnlyKeywords = [\n      '$schema',\n      '$id',\n      '$defs',\n      'definitions',\n      'patternProperties',\n      'dependencies',\n      'propertyNames',\n      'contains',\n      'additionalItems',\n      'if',\n      'then',\n      'else'\n    ];\n\n    jsonSchemaOnlyKeywords.forEach(keyword => {\n      delete (result as any)[keyword];\n    });\n  }\n\n  return result;\n};\n\n/**\n * Transforms JSON Schema $ref to OpenAPI compatible format\n */\nfunction transformRef(ref: string): string {\n  // JSON Schema often uses #/$defs/... while OpenAPI uses #/components/schemas/...\n  if (ref.startsWith('#/$defs/')) {\n    return ref.replace('#/$defs/', '#/components/schemas/');\n  }\n\n  if (ref.startsWith('#/definitions/')) {\n    return ref.replace('#/definitions/', '#/components/schemas/');\n  }\n\n  return ref;\n}\n"]}