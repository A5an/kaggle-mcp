{"version":3,"sources":["../src/metorialOpenAI.ts"],"names":[],"mappings":";AAAA,SAAS,oBAAoB;AAC7B,SAAS,oCAAoC;AAQtC,IAAI,iBAAiB;AAAA,EAC1B,iBAAiB,6BAA6B,EAAE,YAAY,KAAK,CAAC;AAAA,EAElE,WAAW,aAAa,EAAE,OAAO,EAAE,SAAS,MAAM,OAAO;AAAA,IACvD,OAAO,MAAM,SAAS,EAAE,IAAI,OAAE;AAblC;AAasC;AAAA,QAChC,MAAM;AAAA,QACN,MAAM,EAAE;AAAA,QACR,cAAa,OAAE,gBAAF,YAAiB;AAAA,QAC9B,YAAY,EAAE,gBAAgB,aAAa;AAAA,QAC3C,QAAQ;AAAA,MACV;AAAA,KAAE;AAAA,IAEF,WAAW,OACT,UAEA,QAAQ;AAAA,MACN,MAAM,IAAI,OAAM,SAAQ;AACtB,YAAI,OAAO,MAAM,QAAQ,KAAK,IAAI;AAClC,YAAI,CAAC,MAAM;AACT,iBAAO;AAAA,YACL,SAAS,KAAK;AAAA,YACd,MAAM;AAAA,YACN,QAAQ,2BAA2B,KAAK,IAAI;AAAA,UAC9C;AAAA,QACF;AAEA,YAAI,OAAY,CAAC;AAEjB,YAAI;AACF,iBAAO,KAAK,MAAM,KAAK,SAAS;AAAA,QAClC,SAAS,GAAQ;AACf,iBAAO;AAAA,YACL,SAAS,KAAK;AAAA,YACd,MAAM;AAAA,YACN,QAAQ,gDAAgD,EAAE,OAAO;AAAA,UACnE;AAAA,QACF;AAEA,YAAI;AACF,cAAI,SAAS,MAAM,KAAK,KAAK,IAAI;AAEjC,iBAAO;AAAA,YACL,SAAS,KAAK;AAAA,YACd,MAAM;AAAA,YACN,QAAQ,KAAK,UAAU,MAAM;AAAA,UAC/B;AAAA,QACF,SAAS,GAAQ;AACf,iBAAO;AAAA,YACL,SAAS,KAAK;AAAA,YACd,MAAM;AAAA,YACN,QAAQ,6BAA6B,EAAE,OAAO;AAAA,UAChD;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACJ,EAAE;AACJ","sourcesContent":["import { createMcpSdk } from '@metorial/mcp-sdk-utils';\nimport { createOpenAICompatibleMcpSdk } from '@metorial/openai-compatible';\nimport type {\n  ResponseFunctionToolCall,\n  ResponseFunctionToolCallItem,\n  ResponseInputItem\n} from 'openai/resources/responses/responses';\nimport type { FunctionParameters } from 'openai/resources/shared';\n\nexport let metorialOpenAI = {\n  chatCompletions: createOpenAICompatibleMcpSdk({ withStrict: true }),\n\n  responses: createMcpSdk()(async ({ session, tools }) => ({\n    tools: tools.getTools().map(t => ({\n      type: 'function' as const,\n      name: t.id,\n      description: t.description ?? undefined,\n      parameters: t.getParametersAs('json-schema') as FunctionParameters,\n      strict: true\n    })),\n\n    callTools: async (\n      calls: (ResponseFunctionToolCall | ResponseFunctionToolCallItem)[]\n    ): Promise<ResponseInputItem.FunctionCallOutput[]> =>\n      Promise.all(\n        calls.map(async call => {\n          let tool = tools.getTool(call.name);\n          if (!tool) {\n            return {\n              call_id: call.call_id,\n              type: 'function_call_output' as const,\n              output: `[ERROR] Tool with name \"${call.name}\" not found.`\n            } satisfies ResponseInputItem.FunctionCallOutput;\n          }\n\n          let data: any = {};\n\n          try {\n            data = JSON.parse(call.arguments);\n          } catch (e: any) {\n            return {\n              call_id: call.call_id,\n              type: 'function_call_output' as const,\n              output: `[ERROR] Invalid JSON in tool call arguments: ${e.message}`\n            } satisfies ResponseInputItem.FunctionCallOutput;\n          }\n\n          try {\n            let result = await tool.call(data);\n\n            return {\n              call_id: call.call_id,\n              type: 'function_call_output' as const,\n              output: JSON.stringify(result)\n            } satisfies ResponseInputItem.FunctionCallOutput;\n          } catch (e: any) {\n            return {\n              call_id: call.call_id,\n              type: 'function_call_output' as const,\n              output: `[ERROR] Tool call failed: ${e.message}`\n            } satisfies ResponseInputItem.FunctionCallOutput;\n          }\n        })\n      )\n  }))\n};\n"]}