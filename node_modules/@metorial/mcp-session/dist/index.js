import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';
import { CallToolResultSchema } from '@modelcontextprotocol/sdk/types.js';
import { jsonSchemaToOpenApi } from '@metorial/json-schema';

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  member.set(obj, value);
  return value;
};
var MetorialMcpClient = class _MetorialMcpClient {
  constructor(client) {
    this.client = client;
  }
  static async create(session, opts) {
    var _a, _b;
    let client = new Client({
      name: (_a = opts == null ? void 0 : opts.clientName) != null ? _a : "metorial-js-client",
      version: (_b = opts == null ? void 0 : opts.clientVersion) != null ? _b : "1.0.0"
    });
    let transport = new SSEClientTransport(
      new URL(
        `/mcp/${session.id}/${opts.deploymentId}/sse?key=${session.clientSecret.secret}`,
        opts.host
      )
    );
    await client.connect(transport);
    return new _MetorialMcpClient(client);
  }
  registerCapabilities(capabilities) {
    return this.client.registerCapabilities(capabilities);
  }
  getServerCapabilities() {
    return this.client.getServerCapabilities();
  }
  getServerVersion() {
    return this.client.getServerVersion();
  }
  getInstructions() {
    return this.client.getInstructions();
  }
  complete(params, options) {
    return this.client.complete(params, options);
  }
  setLoggingLevel(level, options) {
    return this.client.setLoggingLevel(level, options);
  }
  getPrompt(params, options) {
    return this.client.getPrompt(params, options);
  }
  listPrompts(params, options) {
    return this.client.listPrompts(params, options);
  }
  listResources(params, options) {
    return this.client.listResources(params, options);
  }
  listResourceTemplates(params, options) {
    return this.client.listResourceTemplates(params, options);
  }
  readResource(params, options) {
    return this.client.readResource(params, options);
  }
  callTool(params, resultSchema = CallToolResultSchema, options) {
    return this.client.callTool(params, resultSchema, options);
  }
  listTools(params, options) {
    return this.client.listTools(params, options);
  }
  sendRootsListChanged() {
    return this.client.sendRootsListChanged();
  }
  close() {
    return this.client.close();
  }
};

// src/lib/mcpUri.ts
var McpUriTemplate = class {
  constructor(template) {
    this.template = template;
    this.segments = this.parseTemplate(template);
  }
  parseTemplate(template) {
    let pattern = /\{(\/)?([\w]+)(\*)?\}/g;
    let match;
    let lastIndex = 0;
    let parts = [];
    while ((match = pattern.exec(template)) !== null) {
      let [fullMatch, leadingSlash, key, star] = match;
      if (match.index > lastIndex) {
        parts.push(template.slice(lastIndex, match.index));
      }
      parts.push({
        key,
        explode: !!star,
        optional: !!leadingSlash
      });
      lastIndex = match.index + fullMatch.length;
    }
    if (lastIndex < template.length) {
      parts.push(template.slice(lastIndex));
    }
    return parts;
  }
  getProperties() {
    return this.segments.filter((part) => typeof part !== "string").map((part) => part);
  }
  getKeys() {
    return this.getProperties().map((part) => part.key);
  }
  expand(values) {
    return this.segments.map((segment) => {
      if (typeof segment === "string")
        return segment;
      let { key, explode, optional } = segment;
      let value = values[key];
      if (value === void 0 || value === null) {
        if (optional)
          return "";
        throw new Error(`Missing value for required key: ${key}`);
      }
      if (Array.isArray(value)) {
        return (optional ? "/" : "") + value.map(encodeURIComponent).join("/");
      } else {
        return (optional ? "/" : "") + encodeURIComponent(value);
      }
    }).join("");
  }
};

// src/lib/slugify.ts
var slugify = (input) => input.toLowerCase().trim().replace(/\s+/g, "-").replace(/[^a-z0-9_-]/g, "").replace(/-+/g, "-").replace(/^-+|-+$/g, "");

// src/mcpTool.ts
var MAX_RETRIES = 10;
var runWithRetries = async (action, retries = MAX_RETRIES) => {
  let err;
  for (let i = 0; i < retries; i++) {
    try {
      return await action();
    } catch (error) {
      err = error;
    }
  }
  throw err;
};
var _id, _name, _description, _parameters;
var _MetorialMcpTool = class _MetorialMcpTool {
  constructor(session, opts, action) {
    this.session = session;
    this.action = action;
    __privateAdd(this, _id, void 0);
    __privateAdd(this, _name, void 0);
    __privateAdd(this, _description, void 0);
    __privateAdd(this, _parameters, void 0);
    __privateSet(this, _id, opts.id);
    __privateSet(this, _name, opts.name);
    __privateSet(this, _description, opts.description);
    __privateSet(this, _parameters, opts.parameters);
  }
  get name() {
    return __privateGet(this, _name);
  }
  get id() {
    return __privateGet(this, _id);
  }
  get description() {
    return __privateGet(this, _description);
  }
  get parameters() {
    return __privateGet(this, _parameters);
  }
  async call(args) {
    return await this.action(args);
  }
  getParametersAs(as = "json-schema") {
    if (as == "json-schema")
      return __privateGet(this, _parameters);
    if (as == "openapi-3.0.0" || as == "openapi-3.1.0") {
      return jsonSchemaToOpenApi(__privateGet(this, _parameters), {
        openApiVersion: as == "openapi-3.0.0" ? "3.0.0" : "3.1.0",
        preserveJsonSchemaKeywords: false,
        nullHandling: "nullable"
      });
    }
    throw new Error(`[METORIAL MCP]: Unknown parameters format: ${as}`);
  }
  static fromTool(session, capability) {
    var _a;
    if (capability.type !== "tool") {
      throw new Error(
        `[METORIAL MCP]: Expected capability type to be 'tool', got '${capability.type}'`
      );
    }
    let { tool, serverDeployment } = capability;
    return new _MetorialMcpTool(
      session,
      {
        id: slugify(tool.name),
        name: tool.name,
        description: (_a = tool.description) != null ? _a : null,
        parameters: tool.inputSchema
      },
      async (params) => runWithRetries(async () => {
        let client = await session.getClient({
          deploymentId: serverDeployment.id
        });
        let result = await client.callTool({
          name: tool.name,
          arguments: params
        });
        return result;
      }, MAX_RETRIES)
    );
  }
  static fromResourceTemplate(session, capability) {
    var _a;
    if (capability.type !== "resource-template") {
      throw new Error(
        `[METORIAL MCP]: Expected capability type to be 'resource-template', got '${capability.type}'`
      );
    }
    let { resourceTemplate, serverDeployment } = capability;
    let uri = new McpUriTemplate(resourceTemplate.uriTemplate);
    return new _MetorialMcpTool(
      session,
      {
        id: slugify(resourceTemplate.name),
        name: resourceTemplate.name,
        description: (_a = resourceTemplate.description) != null ? _a : null,
        parameters: {
          type: "object",
          properties: Object.fromEntries(
            uri.getProperties().map((prop) => [prop.key, { type: "string" }])
          ),
          required: uri.getProperties().filter((prop) => !prop.optional).map((prop) => prop.key),
          additionalProperties: false
        }
      },
      async (params) => runWithRetries(async () => {
        let client = await session.getClient({
          deploymentId: serverDeployment.id
        });
        let finalUri = uri.expand(params);
        let result = await client.readResource({
          uri: finalUri
        });
        return result;
      }, MAX_RETRIES)
    );
  }
  static fromCapability(session, capability) {
    if (capability.type === "tool") {
      return _MetorialMcpTool.fromTool(session, capability);
    }
    if (capability.type === "resource-template") {
      return _MetorialMcpTool.fromResourceTemplate(session, capability);
    }
    throw new Error(
      `[METORIAL MCP]: Unknown capability type: ${capability}. Expected 'tool' or 'resource-template'.`
    );
  }
};
_id = new WeakMap();
_name = new WeakMap();
_description = new WeakMap();
_parameters = new WeakMap();
var MetorialMcpTool = _MetorialMcpTool;

// src/mcpToolManager.ts
var _tools;
var _MetorialMcpToolManager = class _MetorialMcpToolManager {
  constructor(session, tools) {
    this.session = session;
    __privateAdd(this, _tools, /* @__PURE__ */ new Map());
    for (let tool of tools) {
      __privateGet(this, _tools).set(tool.id, tool);
      __privateGet(this, _tools).set(tool.name, tool);
    }
  }
  static async fromCapabilities(session, capabilities) {
    return new _MetorialMcpToolManager(
      session,
      capabilities.map((c) => MetorialMcpTool.fromCapability(session, c))
    );
  }
  getTool(idOrName) {
    return __privateGet(this, _tools).get(idOrName);
  }
  getTools() {
    return Array.from(__privateGet(this, _tools).values());
  }
  callTool(idOrName, args) {
    let tool = this.getTool(idOrName);
    if (!tool)
      throw new Error(`Tool not found: ${idOrName}`);
    return tool.call(args);
  }
};
_tools = new WeakMap();
var MetorialMcpToolManager = _MetorialMcpToolManager;

// src/mcpSession.ts
var _sessionPromise, _clientPromises;
var MetorialMcpSession = class {
  constructor(sdk, init) {
    this.sdk = sdk;
    this.init = init;
    __privateAdd(this, _sessionPromise, void 0);
    __privateAdd(this, _clientPromises, /* @__PURE__ */ new Map());
    __privateSet(this, _sessionPromise, this.sdk.sessions.create(init));
  }
  async getSession() {
    return await __privateGet(this, _sessionPromise);
  }
  async getServerDeployments() {
    let session = await this.getSession();
    return session.serverDeployments;
  }
  async getCapabilities() {
    let deployments = await this.getServerDeployments();
    let capabilities = await this.sdk.servers.capabilities.list({
      serverDeploymentId: deployments.map((d) => d.id)
    });
    let serversMap = new Map(capabilities.mcpServers.map((server) => [server.id, server]));
    let capabilitiesByDeploymentId = /* @__PURE__ */ new Map();
    for (let capability of capabilities.tools) {
      let server = serversMap.get(capability.mcpServerId);
      if (!server || !server.serverDeployment)
        continue;
      let current = capabilitiesByDeploymentId.get(server.serverDeployment.id) || [];
      current.push({
        type: "tool",
        tool: capability,
        serverDeployment: server.serverDeployment
      });
      capabilitiesByDeploymentId.set(server.serverDeployment.id, current);
    }
    for (let capability of capabilities.resourceTemplates) {
      let server = serversMap.get(capability.mcpServerId);
      if (!server || !server.serverDeployment)
        continue;
      let current = capabilitiesByDeploymentId.get(server.serverDeployment.id) || [];
      current.push({
        type: "resource-template",
        resourceTemplate: capability,
        serverDeployment: server.serverDeployment
      });
      capabilitiesByDeploymentId.set(server.serverDeployment.id, current);
    }
    let deploymentCapabilities = await Promise.all(
      deployments.map(async (deployment) => {
        let capabilities2 = capabilitiesByDeploymentId.get(deployment.id);
        if (!capabilities2)
          capabilities2 = [];
        if (capabilities2.length)
          return capabilities2;
        let client = await this.getClient({ deploymentId: deployment.id });
        try {
          let tools = await client.listTools();
          capabilities2.push(
            ...tools.tools.map((tool) => ({
              type: "tool",
              tool: {
                name: tool.name,
                description: tool.description,
                inputSchema: tool.inputSchema
              },
              serverDeployment: deployment
            }))
          );
        } catch (error) {
        }
        try {
          let resourceTemplates = await client.listResourceTemplates();
          capabilities2.push(
            ...resourceTemplates.resourceTemplates.map((resourceTemplate) => ({
              type: "resource-template",
              resourceTemplate: {
                name: resourceTemplate.name,
                description: resourceTemplate.description,
                uriTemplate: resourceTemplate.uriTemplate
              },
              serverDeployment: deployment
            }))
          );
        } catch (error) {
        }
        return capabilities2;
      })
    );
    return Array.from(deploymentCapabilities.values()).flat();
  }
  async getToolManager() {
    return MetorialMcpToolManager.fromCapabilities(this, await this.getCapabilities());
  }
  async close() {
    await Promise.all(
      Array.from(__privateGet(this, _clientPromises).values()).map(
        (clientPromise) => clientPromise.then((client) => client.close())
      )
    );
  }
  async getClient(opts) {
    var _a, _b;
    if (!__privateGet(this, _clientPromises).has(opts.deploymentId)) {
      let session = await this.getSession();
      __privateGet(this, _clientPromises).set(
        opts.deploymentId,
        MetorialMcpClient.create(session, {
          host: this.mcpHost,
          deploymentId: opts.deploymentId,
          clientName: (_a = this.init.client) == null ? void 0 : _a.name,
          clientVersion: (_b = this.init.client) == null ? void 0 : _b.version
        })
      );
    }
    return await __privateGet(this, _clientPromises).get(opts.deploymentId);
  }
  get mcpHost() {
    var _a;
    if (this.sdk._config.mcpHost)
      return this.sdk._config.mcpHost;
    let host = (_a = this.sdk._config.apiHost) != null ? _a : "https://api.metorial.com";
    if (host.startsWith("https://api.metorial")) {
      return host.replace("https://api.metorial", "https://mcp.metorial");
    }
    let url = new URL(host);
    url.port = "3311";
    return url.toString();
  }
};
_sessionPromise = new WeakMap();
_clientPromises = new WeakMap();

export { MetorialMcpClient, MetorialMcpSession };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map