interface MetorialRequest {
    path: string | string[];
    host?: string;
    query?: Record<string, any>;
    body?: Record<string, any> | FormData;
    headers?: Record<string, string>;
}
declare class MetorialEndpointManager<Config> {
    readonly config: Config;
    readonly apiHost: string;
    readonly getHeaders: (config: Config) => Record<string, string>;
    readonly fetchImpl: typeof fetch | undefined | null;
    private readonly options;
    constructor(config: Config, apiHost: string, getHeaders: (config: Config) => Record<string, string>, fetchImpl: typeof fetch | undefined | null, options: {
        enableDebugLogging: boolean;
    });
    get fetch(): typeof fetch;
    private request;
    private requestAndTransform;
    _get(request: MetorialRequest): {
        transform: <T>(mapper: {
            transformFrom: (input: any) => T;
        }) => Promise<T>;
    };
    _post(request: MetorialRequest): {
        transform: <T>(mapper: {
            transformFrom: (input: any) => T;
        }) => Promise<T>;
    };
    _put(request: MetorialRequest): {
        transform: <T>(mapper: {
            transformFrom: (input: any) => T;
        }) => Promise<T>;
    };
    _patch(request: MetorialRequest): {
        transform: <T>(mapper: {
            transformFrom: (input: any) => T;
        }) => Promise<T>;
    };
    _delete(request: MetorialRequest): {
        transform: <T>(mapper: {
            transformFrom: (input: any) => T;
        }) => Promise<T>;
    };
}
declare abstract class BaseMetorialEndpoint<Config> {
    protected readonly manager: MetorialEndpointManager<Config>;
    constructor(manager: MetorialEndpointManager<Config>);
    protected _get(request: MetorialRequest): {
        transform: <T>(mapper: {
            transformFrom: (input: any) => T;
        }) => Promise<T>;
    };
    protected _post(request: MetorialRequest): {
        transform: <T>(mapper: {
            transformFrom: (input: any) => T;
        }) => Promise<T>;
    };
    protected _put(request: MetorialRequest): {
        transform: <T>(mapper: {
            transformFrom: (input: any) => T;
        }) => Promise<T>;
    };
    protected _patch(request: MetorialRequest): {
        transform: <T>(mapper: {
            transformFrom: (input: any) => T;
        }) => Promise<T>;
    };
    protected _delete(request: MetorialRequest): {
        transform: <T>(mapper: {
            transformFrom: (input: any) => T;
        }) => Promise<T>;
    };
}

declare class MetorialSDKError extends Error {
    readonly response: {
        status: number;
        code: string;
        message: string;
        hint?: string;
        description?: string;
        entity?: string;
        reason?: string;
        errors?: {
            code: string;
            message: string;
            expected?: any;
            received?: any;
            path?: string[];
            min?: number;
            max?: number;
            positive?: boolean;
            negative?: boolean;
        }[];
        [key: string]: any;
    };
    __typename: "metorial.sdk.error";
    __isMetorialError: boolean;
    constructor(response: {
        status: number;
        code: string;
        message: string;
        hint?: string;
        description?: string;
        entity?: string;
        reason?: string;
        errors?: {
            code: string;
            message: string;
            expected?: any;
            received?: any;
            path?: string[];
            min?: number;
            max?: number;
            positive?: boolean;
            negative?: boolean;
        }[];
        [key: string]: any;
    });
    get code(): string;
    get message(): string;
    get hint(): string | undefined;
    get description(): string | undefined;
    get reason(): string | undefined;
    get validationErrors(): {
        code: string;
        message: string;
        expected?: any;
        received?: any;
        path?: string[];
        min?: number;
        max?: number;
        positive?: boolean;
        negative?: boolean;
    }[] | undefined;
    get entity(): string | undefined;
}
declare let isMetorialSDKError: (error: any) => error is MetorialSDKError;

declare class MetorialSDKBuilder<ApiVersion, Config extends {
    apiKey?: string;
    apiVersion: ApiVersion;
    fetch?: typeof fetch;
}> {
    #private;
    private apiName;
    private apiVersion;
    private constructor();
    static create<ApiVersion, Config extends {
        apiVersion: ApiVersion;
        apiKey?: string;
    }>(apiName: string, apiVersion: ApiVersion): MetorialSDKBuilder<ApiVersion, Config>;
    setGetApiHost(getApiHost: (config: Config) => string): this;
    setGetHeaders(getHeaders: (config: Config) => Record<string, string>): this;
    build<SoftConfig extends Partial<Config>>(getConfig: (config: SoftConfig) => Config): <E extends {
        [key: string]: any;
    }>(getEndpoints: (manager: MetorialEndpointManager<Config>) => E) => (config: SoftConfig & {
        enableDebugLogging?: boolean;
    }) => E & {
        _config: Config & {
            apiHost: string;
        };
    };
}
type GetMetorialSDKConfig<Builder extends MetorialSDKBuilder<any, any>> = Builder extends MetorialSDKBuilder<infer ApiVersion, infer Config> ? Config : never;

export { BaseMetorialEndpoint, type GetMetorialSDKConfig, MetorialEndpointManager, type MetorialRequest, MetorialSDKBuilder, MetorialSDKError, isMetorialSDKError };
