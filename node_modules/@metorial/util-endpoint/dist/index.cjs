"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BaseMetorialEndpoint: () => BaseMetorialEndpoint,
  MetorialEndpointManager: () => MetorialEndpointManager,
  MetorialSDKBuilder: () => MetorialSDKBuilder,
  MetorialSDKError: () => MetorialSDKError,
  isMetorialSDKError: () => isMetorialSDKError
});
module.exports = __toCommonJS(src_exports);

// src/fetch.ts
var import_cross_fetch = __toESM(require("cross-fetch"), 1);
if (typeof globalThis.fetch !== "function") {
  globalThis.fetch = import_cross_fetch.default;
  globalThis.Headers = import_cross_fetch.Headers;
  globalThis.Request = import_cross_fetch.Request;
  globalThis.Response = import_cross_fetch.Response;
}

// src/endpoints.ts
var import_qs = __toESM(require("qs"), 1);

// src/error.ts
var METORIAL_SDK_ERROR = "metorial.sdk.error";
var MetorialSDKError = class extends Error {
  constructor(response) {
    super(`[METORIAL ERROR]: ${response.code} - ${response.message}`);
    this.response = response;
    this.__typename = METORIAL_SDK_ERROR;
    this.__isMetorialError = true;
  }
  get code() {
    return this.response.code;
  }
  get message() {
    return this.response.message;
  }
  get hint() {
    return this.response.hint;
  }
  get description() {
    return this.response.description;
  }
  get reason() {
    return this.response.reason;
  }
  get validationErrors() {
    return this.response.errors;
  }
  get entity() {
    return this.response.entity;
  }
};
var isMetorialSDKError = (error) => {
  return (error == null ? void 0 : error.__typename) === METORIAL_SDK_ERROR || error.__isMetorialError || error instanceof MetorialSDKError;
};

// src/endpoints.ts
var MetorialEndpointManager = class {
  constructor(config, apiHost, getHeaders, fetchImpl, options) {
    this.config = config;
    this.apiHost = apiHost;
    this.getHeaders = getHeaders;
    this.fetchImpl = fetchImpl;
    this.options = options;
  }
  get fetch() {
    var _a;
    return (_a = this.fetchImpl) != null ? _a : globalThis.fetch.bind(globalThis);
  }
  async request(method, request, tryCount = 0) {
    var _a, _b, _c, _d, _e;
    let path = Array.isArray(request.path) ? request.path.join("/") : request.path;
    let url = new URL((_a = request.host) != null ? _a : this.apiHost);
    url.pathname = url.pathname.replace(/\/$/, "") + "/" + path.replace(/^\//, "");
    if (request.query) {
      url.search = import_qs.default.stringify(request.query);
    }
    let defaultHeaders = (_c = (_b = this.getHeaders) == null ? void 0 : _b.call(this, this.config)) != null ? _c : {};
    let mergedHeaders = {
      ...defaultHeaders,
      ...(_d = request.headers) != null ? _d : {}
    };
    let headers = new Headers(mergedHeaders);
    let hasBody = method === "POST" || method === "PUT" || method === "PATCH";
    let isFormData = request.body instanceof FormData;
    if (hasBody && !isFormData && !headers.has("Content-Type")) {
      headers.set("Content-Type", "application/json");
    }
    if (this.options.enableDebugLogging) {
      console.log(`[Metorial] ${method} ${url.toString()}`, {
        body: request.body,
        query: request.query,
        headers: Object.fromEntries(headers.entries())
      });
    }
    let response;
    try {
      response = await this.fetch(url.toString(), {
        method,
        headers,
        body: hasBody ? isFormData ? request.body : JSON.stringify((_e = request.body) != null ? _e : {}) : void 0,
        credentials: "include",
        redirect: "follow",
        referrerPolicy: "no-referrer-when-downgrade",
        cache: "no-cache",
        keepalive: true,
        mode: "cors"
      });
      if (response.status === 429 && tryCount < 3) {
        let retryAfter = response.headers.get("Retry-After");
        if (retryAfter) {
          await new Promise((resolve) => setTimeout(resolve, (parseInt(retryAfter) + 3) * 1e3));
          return this.request(method, request, tryCount + 1);
        }
      }
    } catch (error) {
      if (this.options.enableDebugLogging) {
        console.error(`[Metorial] ${method} ${url.toString()}`, error);
      }
      throw new MetorialSDKError({
        status: 0,
        code: "network_error",
        message: "Unable to connect to Metorial API - please check your internet connection"
      });
    }
    let data;
    try {
      data = await response.json();
    } catch (error) {
      if (this.options.enableDebugLogging) {
        console.error(`[Metorial] ${method} ${url.toString()}`, error);
      }
      throw new MetorialSDKError({
        status: response.status,
        code: "malformed_response",
        message: "The Metorial API returned an unexpected response. Expected JSON."
      });
    }
    if (!response.ok) {
      if (this.options.enableDebugLogging) {
        console.error(`[Metorial] ${method} ${url.toString()}`, data);
      }
      throw new MetorialSDKError(data);
    }
    if (this.options.enableDebugLogging) {
      console.log(`[Metorial] ${method} ${url.toString()}`, data);
    }
    return data;
  }
  requestAndTransform(method, request) {
    return {
      transform: async (mapper) => {
        let data = await this.request(method, request);
        return mapper.transformFrom(data);
      }
    };
  }
  _get(request) {
    return this.requestAndTransform("GET", request);
  }
  _post(request) {
    return this.requestAndTransform("POST", request);
  }
  _put(request) {
    return this.requestAndTransform("PUT", request);
  }
  _patch(request) {
    return this.requestAndTransform("PATCH", request);
  }
  _delete(request) {
    return this.requestAndTransform("DELETE", request);
  }
};
var BaseMetorialEndpoint = class {
  constructor(manager) {
    this.manager = manager;
  }
  _get(request) {
    return this.manager._get(request);
  }
  _post(request) {
    return this.manager._post(request);
  }
  _put(request) {
    return this.manager._put(request);
  }
  _patch(request) {
    return this.manager._patch(request);
  }
  _delete(request) {
    return this.manager._delete(request);
  }
};

// src/sdkBuilder.ts
var _getApiHost, _getHeaders;
var _MetorialSDKBuilder = class _MetorialSDKBuilder {
  constructor(apiName, apiVersion) {
    this.apiName = apiName;
    this.apiVersion = apiVersion;
    __privateAdd(this, _getApiHost, void 0);
    __privateAdd(this, _getHeaders, void 0);
  }
  static create(apiName, apiVersion) {
    return new _MetorialSDKBuilder(apiName, apiVersion);
  }
  setGetApiHost(getApiHost) {
    __privateSet(this, _getApiHost, getApiHost);
    return this;
  }
  setGetHeaders(getHeaders) {
    __privateSet(this, _getHeaders, getHeaders);
    return this;
  }
  build(getConfig) {
    if (!__privateGet(this, _getHeaders)) {
      throw new Error("getHeaders must be set");
    }
    if (!__privateGet(this, _getApiHost)) {
      throw new Error("apiHost must be set");
    }
    return (getEndpoints) => (config) => {
      let fullConfig = getConfig(config);
      let apiHost = __privateGet(this, _getApiHost).call(this, fullConfig);
      let manager = new MetorialEndpointManager(
        fullConfig,
        apiHost,
        __privateGet(this, _getHeaders),
        fullConfig.fetch,
        { enableDebugLogging: !!fullConfig.enableDebugLogging }
      );
      return {
        _config: {
          apiHost,
          ...fullConfig
        },
        ...getEndpoints(manager)
      };
    };
  }
};
_getApiHost = new WeakMap();
_getHeaders = new WeakMap();
var MetorialSDKBuilder = _MetorialSDKBuilder;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BaseMetorialEndpoint,
  MetorialEndpointManager,
  MetorialSDKBuilder,
  MetorialSDKError,
  isMetorialSDKError
});
//# sourceMappingURL=index.cjs.map