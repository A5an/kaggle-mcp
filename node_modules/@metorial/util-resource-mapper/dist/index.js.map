{"version":3,"sources":["../src/mappers/array.ts","../src/mappers/date.ts","../src/mappers/object.ts","../src/mappers/passthrough.ts","../src/mappers/union.ts","../src/index.ts"],"sourcesContent":["import { MetorialMapper } from '../types';\n\nexport let arrayMapper = <T = any>(mapper: MetorialMapper<T>): MetorialMapper<T> => ({\n  transformFrom: (input: any): T => {\n    if (!Array.isArray(input)) return input;\n    if (input.length == 0) return input as T;\n\n    return input.map((item: any) => mapper.transformFrom(item)) as T;\n  },\n\n  transformTo: (input: any) => {\n    if (!Array.isArray(input)) return input;\n    if (input.length == 0) return input;\n\n    return input.map((item: any) => mapper.transformTo(item));\n  }\n});\n","import { MetorialMapper } from '../types';\n\nlet toDate = (input: any): Date => {\n  if (input instanceof Date) return input;\n\n  if (typeof input === 'string' || typeof input === 'number') {\n    let date = new Date(input);\n    if (!isNaN(date.getTime())) return date;\n  }\n\n  return input;\n};\n\nexport let dateMapper = (): MetorialMapper<Date> => ({\n  transformFrom: (input: any): Date => toDate(input),\n  transformTo: (input: any): Date => toDate(input)\n});\n","import { MetorialMapper } from '../types';\n\nexport let objectMapper = <T = any>(\n  properties: Record<string, MetorialObjectMapperField>\n): MetorialMapper<T> => {\n  let fromTransformers = new Map(\n    Object.entries(properties).map(([toKey, value]) => [\n      value.fromKey,\n      { toKey, mapper: value.mapper }\n    ])\n  );\n\n  let toTransformers = new Map(\n    Object.entries(properties).map(([toKey, value]) => [\n      toKey,\n      { fromKey: value.fromKey, mapper: value.mapper }\n    ])\n  );\n\n  return {\n    transformFrom: (input: any): T => {\n      if (typeof input != 'object' || input == null) return input;\n\n      let output: any = {};\n      let keys = new Set(Object.keys(input));\n\n      for (let [fromKey, { toKey, mapper }] of fromTransformers) {\n        if (!keys.has(fromKey)) continue;\n\n        output[toKey] = mapper.transformFrom(input[fromKey]);\n        keys.delete(fromKey);\n      }\n\n      for (let key of keys) {\n        output[key] = input[key];\n      }\n\n      return output;\n    },\n\n    transformTo: (input: any) => {\n      if (typeof input != 'object' || input == null) return input;\n\n      let output: any = {};\n      let keys = new Set(Object.keys(input));\n\n      for (let [toKey, { fromKey, mapper }] of toTransformers) {\n        if (!keys.has(toKey)) continue;\n\n        output[fromKey] = mapper.transformTo(input[toKey]);\n        keys.delete(toKey);\n      }\n\n      for (let key of keys) {\n        output[key] = input[key];\n      }\n\n      return output;\n    }\n  };\n};\n\nexport let objectField = (\n  fromKey: string,\n  mapper: MetorialMapper<any>\n): MetorialObjectMapperField => ({\n  fromKey,\n  mapper\n});\n\nexport interface MetorialObjectMapperField {\n  fromKey: string;\n  mapper: MetorialMapper<any>;\n}\n","import { MetorialMapper } from '../types';\n\nexport let passthroughMapper = (): MetorialMapper<any> => ({\n  transformFrom: (input: any) => input,\n  transformTo: (input: any) => input\n});\n","import { MetorialMapper } from '../types';\n\nlet getType = (input: any): string => {\n  if (Array.isArray(input)) return 'array';\n  if (input instanceof Date) return 'date';\n  if (typeof input == 'object' && input != null) return 'object';\n  return typeof input;\n};\n\nexport let unionMapper = (options: MetorialUnionMapperOption[]): MetorialMapper<any> => {\n  let mappersByType = new Map(options.map(o => [o.type, o.mapper]));\n\n  return {\n    transformFrom: (input: any) => {\n      let mapper = mappersByType.get(getType(input));\n      if (!mapper) return input;\n\n      return mapper.transformFrom(input);\n    },\n\n    transformTo: (input: any) => {\n      let mapper = mappersByType.get(getType(input));\n      if (!mapper) return input;\n\n      return mapper.transformTo(input);\n    }\n  };\n};\n\nexport let unionOption = (\n  type: string,\n  mapper: MetorialMapper<any>\n): MetorialUnionMapperOption => ({\n  type,\n  mapper\n});\n\nexport interface MetorialUnionMapperOption {\n  type: string;\n  mapper: MetorialMapper<any>;\n}\n","import {\n  arrayMapper,\n  dateMapper,\n  objectField,\n  objectMapper,\n  passthroughMapper,\n  unionMapper,\n  unionOption\n} from './mappers';\n\nexport * from './types';\n\nexport let mtMap = {\n  object: objectMapper,\n  objectField,\n\n  union: unionMapper,\n  unionOption,\n\n  array: arrayMapper,\n\n  date: dateMapper,\n\n  passthrough: passthroughMapper\n};\n"],"mappings":"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","names":[]}